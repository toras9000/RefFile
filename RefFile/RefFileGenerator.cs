using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;

namespace RefFile;

/// <summary>指定したファイルをそのまま取り込むジェネレータ</summary>
/// <remarks>
/// このジェネレータは主に .NET10 の file-based apps で外部ファイルをコードに取り込む目的のものとなる。
/// .NET11 で複数ファイルサポートが追加されるまでの繋ぎとして利用することを想定している。
/// </remarks>
[Generator(LanguageNames.CSharp)]
public partial class RefFileGenerator : IIncrementalGenerator
{
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 初期化処理登録
        context.RegisterPostInitializationOutput(PostInitializationOutput);

        // 属性反応したソース生成ハンドラ登録
        var refSource = context.SyntaxProvider.ForAttributeWithMetadataName(
            fullyQualifiedMetadataName: "RefFileAttribute",
            predicate: (node, token) => true,
            transform: (context, token) => context
        );
        context.RegisterSourceOutput(refSource, GenerateRefSource);
    }

    /// <summary>初期化処理</summary>
    private void PostInitializationOutput(IncrementalGeneratorPostInitializationContext context)
    {
        // ソース生成起点となる外部ファイルを参照する属性コード生成
        context.AddSource("RefFileAttribute.g.cs", """
        // <auto-generated/>
        #nullable enable

        [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true, Inherited = false)]
        internal sealed class RefFileAttribute(string fileName) : Attribute
        {
            public string FileName { get; } = fileName;
        }
        """);
    }

    /// <summary>属性に対してソースを生成するハンドラ</summary>
    private void GenerateRefSource(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        // 生成ソースに重複回避用のハッシュを付けるため、適当な生成処理を作成。なんでもいい。
        using var hasher = MD5.Create();

        // 属性に対する処理
        var invalidChars = Path.GetInvalidPathChars();
        foreach (var attr in source.Attributes)
        {
            // シンタックス情報が参照できなければスキップ
            var syntaxRef = attr.ApplicationSyntaxReference;
            if (syntaxRef == null) continue;

            // 外部ファイル参照の基準ディレクトリ取得。属性を定義しているソースファイルの場所を起点とする。
            var sourcePath = syntaxRef.SyntaxTree.FilePath;
            var basePath = Path.GetDirectoryName(sourcePath);

            // 属性のコンストラクタ引数を取得
            var filePath = attr.ConstructorArguments.FirstOrDefault().Value as string;
            if (string.IsNullOrWhiteSpace(filePath) || filePath.Intersect(invalidChars).Any())
            {
                // パス処理に支障をきたすような文字列ならば処理不可なのでスキップ
                var desc = new DiagnosticDescriptor(
                    id: "REF001",
                    title: "Invalid file name",
                    messageFormat: "The file name parameter is invalid.",
                    category: "RefFile",
                    defaultSeverity: DiagnosticSeverity.Error,
                    isEnabledByDefault: true
                );
                var diag = Diagnostic.Create(desc, syntaxRef.GetSyntax().GetLocation());
                context.ReportDiagnostic(diag);
                continue;
            }

            try
            {
                // 参照する外部ファイルの情報を取得
                var fileName = Path.GetFileName(filePath);
                var fileFullPath = Path.GetFullPath(Path.Combine(basePath, filePath));
                var file = new FileInfo(fileFullPath);
                if (!file.Exists)
                {
                    // 参照ファイルが存在しなければスキップ
                    var desc = new DiagnosticDescriptor(
                        id: "REF002",
                        title: "File does not exist",
                        messageFormat: "The file could not be found.",
                        category: "RefFile",
                        defaultSeverity: DiagnosticSeverity.Error,
                        isEnabledByDefault: true
                    );
                    var diag = Diagnostic.Create(desc, syntaxRef.GetSyntax().GetLocation());
                    context.ReportDiagnostic(diag);
                    continue;
                }

                // ファイルサイズに制限を設ける
                if ((10 * 1024 * 1024) < file.Length)
                {
                    // ファイルが大きすぎるようであればスキップ
                    var desc = new DiagnosticDescriptor(
                        id: "REF003",
                        title: "File size exceeded",
                        messageFormat: "The file size is too large. Files over 10MB cannot be referenced.",
                        category: "RefFile",
                        defaultSeverity: DiagnosticSeverity.Error,
                        isEnabledByDefault: true
                    );
                    var diag = Diagnostic.Create(desc, syntaxRef.GetSyntax().GetLocation());
                    context.ReportDiagnostic(diag);
                    continue;
                }

                // 参照ファイル内容を生成コード用に読み込み
                var importCode = LoadImportCode(file);

                // 重複を避けるように生成コードのファイル名を決定する
                var pathHash = hasher.ComputeHash(Encoding.UTF8.GetBytes(filePath));
                var hashHex = string.Join("", pathHash.Select(x => $"{x:X2}"));
                var genFileName = $"RefFileGenerator-import-{fileName}-{hashHex}.g.cs";

                // 生成ソース
                context.AddSource(genFileName, importCode);
            }
            catch (Exception ex)
            {
                var desc = new DiagnosticDescriptor(
                    id: "REF002",
                    title: "File reference error.",
                    messageFormat: $"File reference error: {ex.Message}",
                    category: "RefFile",
                    defaultSeverity: DiagnosticSeverity.Error,
                    isEnabledByDefault: true
                );
                var diag = Diagnostic.Create(desc, syntaxRef.GetSyntax().GetLocation());
                context.ReportDiagnostic(diag);
            }
        }
    }

    /// <summary>指定されたファイルを生成用に読み取る</summary>
    /// <param name="file">読み取るファイル</param>
    /// <returns>インポートするコード</returns>
    private string LoadImportCode(FileInfo file)
    {
        // ファイル内容をテキストとして読み取り
        var source = "";
        using (var reader = file.OpenText())
        {
            source = reader.ReadToEnd();
        }

        // 先頭に定型コードを出力
        var code = new StringBuilder();
        code.Append("""
        // <auto-generated/>
        #nullable enable

        """);

        // ファイル内容を加工する
        var lineEnds = (stackalloc char[] { '\r', '\n' });
        var scan = source.AsSpan();
        while (!scan.IsEmpty)
        {
            // 行の切り出し
            var lineEnd = scan.IndexOfAny(lineEnds);
            var line = lineEnd < 0 ? scan : scan.Slice(0, lineEnd);
            scan = scan.Slice(line.Length);

            // コメント行判定。行コメントだけサポート。
            var commentLine = line.TrimStart().StartsWith("//");

            // ディレクティブでない行を検出したら、残り全てをそのまま追加して終了
            if (!commentLine && !line.StartsWith("#"))
            {
                code.Append(line.ToArray());
                code.Append(scan.ToArray());
                break;
            }

            // 続く改行コードの長さを判別
            var termLen = scan.IsEmpty ? 0 : (scan.StartsWith("\r\n") ? 2 : 1);

            // 取り込みに当たって除去すべき行であるかを判定
            var ignoreLine = !commentLine && (line.StartsWith("#:") || line.StartsWith("#!"));
            if (!ignoreLine)
            {
                // 除去しない場合はそのまま行を(改行込みで)追加
                code.Append(line.ToArray());
                code.Append(scan.Slice(0, termLen).ToArray());
            }

            // 走査スパンの改行をスキップして次の行へ
            scan = scan.Slice(termLen);
        }

        return code.ToString();
    }
}